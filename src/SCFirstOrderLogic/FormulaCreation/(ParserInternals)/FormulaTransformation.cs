using SCFirstOrderLogic.FormulaCreation.Antlr;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace SCFirstOrderLogic.FormulaCreation;

/// <summary>
/// Visitor that transforms from a syntax tree generated by ANTLR to a <see cref="Formula"/> instance.
/// </summary>
internal class FormulaTransformation : FirstOrderLogicBaseVisitor<Formula>
{
    private readonly FormulaParserOptions options;
    private readonly IEnumerable<VariableDeclaration> variablesInScope;
    private readonly TermTransformation termTransformation;

    public FormulaTransformation(
        FormulaParserOptions options,
        IEnumerable<VariableDeclaration> variablesInScope)
    {
        this.options = options;
        this.variablesInScope = variablesInScope;
        termTransformation = new TermTransformation(options, variablesInScope);
    }

    public override Formula VisitPredicate([NotNull] FirstOrderLogicParser.PredicateContext context)
    {
        return new Predicate(
            options.GetPredicateIdentifier(context.IDENTIFIER().Symbol.Text),
            context.argumentList()._elements.Select(e => termTransformation.Visit(e)));
    }

    public override Formula VisitNegation([NotNull] FirstOrderLogicParser.NegationContext context)
    {
        return new Negation(Visit(context.formula()));
    }

    public override Formula VisitEquivalence([NotNull] FirstOrderLogicParser.EquivalenceContext context)
    {
        var subFormulas = context.formula();
        return new Equivalence(Visit(subFormulas[0]), Visit(subFormulas[1]));
    }

    public override Formula VisitConjunction([NotNull] FirstOrderLogicParser.ConjunctionContext context)
    {
        var subFormulas = context.formula();
        return new Conjunction(Visit(subFormulas[0]), Visit(subFormulas[1]));
    }

    public override Formula VisitExistentialQuantification([NotNull] FirstOrderLogicParser.ExistentialQuantificationContext context)
    {
        var newVariables = context.declarationList()._elements.Select(e => new VariableDeclaration(options.GetVariableOrConstantIdentifier(e.Text)));

        Formula MakeFormula(IEnumerable<VariableDeclaration> remainingVariables)
        {
            if (!remainingVariables.Any())
            {
                return new FormulaTransformation(options, variablesInScope.Concat(newVariables)).Visit(context.formula());
            }
            else
            {
                return new ExistentialQuantification(remainingVariables.First(), MakeFormula(remainingVariables.Skip(1)));
            }
        }

        return MakeFormula(newVariables);
    }

    public override Formula VisitDisjunction([NotNull] FirstOrderLogicParser.DisjunctionContext context)
    {
        var subFormulas = context.formula();
        return new Disjunction(Visit(subFormulas[0]), Visit(subFormulas[1]));
    }

    public override Formula VisitImplication([NotNull] FirstOrderLogicParser.ImplicationContext context)
    {
        var subFormulas = context.formula();
        return new Implication(Visit(subFormulas[0]), Visit(subFormulas[1]));
    }

    public override Formula VisitBracketedFormula([NotNull] FirstOrderLogicParser.BracketedFormulaContext context)
    {
        return Visit(context.formula());
    }

    public override Formula VisitPredicateEquality([NotNull] FirstOrderLogicParser.PredicateEqualityContext context)
    {
        var arguments = context.term();
        return new Predicate(
            EqualityIdentifier.Instance,
            new[] { termTransformation.Visit(arguments[0]), termTransformation.Visit(arguments[1]) });
    }

    public override Formula VisitUniversalQuantification([NotNull] FirstOrderLogicParser.UniversalQuantificationContext context)
    {
        var newVariables = context.declarationList()._elements.Select(e => new VariableDeclaration(options.GetVariableOrConstantIdentifier(e.Text)));

        Formula MakeFormula(IEnumerable<VariableDeclaration> remainingVariables)
        {
            if (!remainingVariables.Any())
            {
                return new FormulaTransformation(options, variablesInScope.Concat(newVariables)).Visit(context.formula());
            }
            else
            {
                return new UniversalQuantification(remainingVariables.First(), MakeFormula(remainingVariables.Skip(1)));
            }
        }

        return MakeFormula(newVariables);
    }
}

